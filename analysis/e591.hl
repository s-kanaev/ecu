/*
TYPES:
 - byte - a byte
 - pin - a pin
*/

typedef uint8_t byte;
typedef uint16_t word;
typedef int pin;

//////////////////////////////// FUNCTIONS:
/* Send DATA byte over SPI interface described by
   MOSI (output), MISO (input) and CLK pins.
   Sends data over MOSI pin.
   Returns byte fetched on MISO pin.
   0 for MISO - no input. */
byte send_by_spi(byte DATA, pin MOSI, pin MISO, pin CLK);

void enable_access_to_xram();
void disable_access_to_xram();

#define WAIT_MACHINE_CYCLES_BY_2(x) /* waits for x*2 machine cycles, x = 0 is 0x100 */
/* BIT_AT(1, 3) = 0x08*/
#define BIT_AT(val, bit) (((val) & 1) << ((bit) & 8))
/* CHECK_BIT_AT(0x10, 4) is true */
#define CHECK_BIT_AT(val, bit) ((val) & (1 << ((bit) & 8)))

//////////////////////////////// CONSTANTS
#define KNOCK_SENSOR_TEST_CONFIG_WORD ((byte)(0x00))
#define KNOCK_SENSOR_TEST_CONFIG_WORD_PREFIX ((byte)0xE0)
#define KNOCK_SENSOR_INTEGRATOR_TIME_CONSTANT_CONFIG_WORD_PREFIX ((byte)0xC0)
#define KNOCK_SENSOR_BALANCE_CONTROL_CONFIG_WORD_PREFIX ((byte)0x80)
#define KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD_PREFIX ((byte)0x40)
#define KNOCK_SENSOR_FILTER_FREQUENCY_CONFIG_WORD_MASK ((byte)0x3F)

#define KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD ((byte)0x01)

//////////////////////////////// General purpose flags:
/*
PSW.5 (F0) - was previously working?
  0 = ignition was turned on for the first time.
PSW.1 (F1) - watchdog failure occurred (?)
*/

//////////////////////////////// MEMORY SECTIONS

////////////// RAM MAP
byte RAM[128] = {
  [0x00..0x07] = 0, // R0..R7 @ register bank 0
  [0x08..0x0f] = 0, // R0..R7 @ register bank 1
  [0x10..0x17] = 0, // R0..R7 @ register bank 2
  [0x18..0x1f] = 0, // R0..R7 @ register bank 3

  // the rest (up to 0x7B, incl.) is initialized with nil
  [0x20] = 0x00, // bit 6 (bit address 0x06) = copy of PSW.F1
                 // bit 7 (bit address 0x07) = if xram check sum was not valid

  [0x21..0x26] = 0x00,

  [0x27] = 0x00, // bit 3 (bit address 0x3B) = copy of PSW.F0

  [0x28..0x2C] = 0x00,
  [0x2D] = 0x00,  // bit 7 = FLASH[873F] bit 4
  [0x2E] = 0x00,  // bit 0 = FLASH[873F] bit 5, bit 1 = FLASH[873F] bit 2
  [0x2F..0x7B] = 0x00,


  [0x7C..0x7D] = 0x00,

  [0x7E..0x7F] = 0x40, // HIP0045 configuration words
};

////////////// FLASH MAP
byte FLASH[0x10000] = {
  /* knock_sensor_balance_control_gain_ratio_table configuration words (bytes), lengts = 0x40 bytes  */
  [0x24EF] = 0x3F,
  [0x24F0] = 0x3F, 0x3F, 0x3F, 0x39, 0x34, 0x31, 0x2F, 0x2D, 0x2A, 0x28, 0x27, 0x25, 0x24, 0x23, 0x22, 0x21,
  [0x2500] = 0x20, 0x1F, 0x1E, 0x1D, 0x1D, 0x1D, 0x1C, 0x1C, 0x1B, 0x1B, 0x1A, 0x19, 0x19, 0x18, 0x18, 0x18,
  [0x2510] = 0x17, 0x16, 0x16, 0x16, 0x15, 0x15, 0x15, 0x14, 0x14, 0x14, 0x14, 0x13, 0x13, 0x13, 0x13, 0x13,
  [0x2520] = 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,

  [0x873F] = 0x3F,  // some status byte ??? 0011 1111
  [0x8741] = 0x23,  // some status byte ??? 0010 0011
                    // bit 0 - is there IROM; default = 1; 0 => FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 1 - should DAC be corrected from IROM; default = 1; 0 => FLASH[0xFFFF] = 0x01, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 2 - 
                    // bit 3 - 
                    // bit 4 - 
                    // bit 5 - 
                    // bit 6 - 
                    // bit 7 - 

  [0x8743] = 0x13,  // some status byte ??? 0001 0011

  /* knock sensor knock filter frequency configuration word */
  [0x87A7] = 0x2C,

  /* offset for knock sensor balance control gain ratio table @ 0x24EF */
  [0x87A9] = 0x30,

  [0xABF1..0xACE8] = 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
                     0x02, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06,
                     0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
                     0x0F, 0x10, 0x12, 0x15, 0x18, 0x1B, 0x1E, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02,
                     0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
                     0x0B, 0x0C, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
                     0x12, 0x14, 0x17, 0x1B, 0x1E, 0x22, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x02, 0x03, 0x04, 0x05, 0x06,
                     0x07, 0x09, 0x0B, 0x0C, 0x0E, 0x0F, 0x10, 0x11,
                     0x12, 0x13, 0x14, 0x14, 0x14, 0x14, 0x15, 0x16,
                     0x17, 0x18, 0x1A, 0x1F, 0x26, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                     0x0B, 0x0E, 0x11, 0x14, 0x17, 0x1B, 0x1F, 0x22,
                     0x24, 0x25, 0x26, 0x26, 0x26, 0x26, 0x25, 0x24,
                     0x23, 0x23, 0x23, 0x23, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
                     0x03, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                     0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x11, 0x13,
                     0x15, 0x17, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03,
                     0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
                     0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x11, 0x13, 0x15,
                     0x17, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03,
                     0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
                     0x0C, 0x0D, 0x0E, 0x0F, 0x11, 0x13, 0x15, 0x17,
                     0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                     0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04,
                     0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                     0x0D, 0x0E, 0x0F, 0x11, 0x13, 0x15, 0x17, 0x19,

  /* knock sensor integration time constant configuration word */
  [0xAE01] = 0x00,
};

////////////// XRAM MAP
byte XRAM[0xC00] = [0xF400..0x10000] = {
  [0xF400..0xF657] = 0,                       //
  [0xF658] = 0,                               // checksum low byte (for 0xFx00..0xF657)
  [0xF659] = 0                                // checksum high byte (for 0xFx00..0xF657)
  [0xF675..0xF7D4] = 0x00,                    // 0x160 bytes
  [0xF7D5..0xF8CC] = FLASH[0xABF1..0xACE8]    // 0xF8 bytes

  [0xF97E] = 0x00,
  [0xF972] = 0x00,
  [0xF973] = 0x00,
  [0xF974] = 0x00
};


//////////////////////////////// Pins

enum Pins {
  P0_0 = 1,
  P0_1,
  // and so on and on and on ...
  P9_7
};


//////////////////////////////// Auxiliary functions

void reset_init(void) {
  disable_interrupts();
  clear_stack();
  reset_interrupt_requests();
  disable_access_to_xram();
  set_clk_out_prescaler(12); // clkout freq = f_osc/12
  select_dptr(0);
}

void init_pins(void) {
/*
  *** SUMMARY ***
  Bidirectional port structure employed.

  PORTS' DIRECTIONS:
  P0 - all in
  P1 - 2, 3 - in; other - out
  P2 - all in
  P3 - 0, 3, 5 - in; other - out
  P4 - 7 - in; others - out
  P5 - 7 - in; others - out
  P6 - all out
  P7 - 
  P8 - 
  P9 - 0, 4, 5 - in; other - out

  PORTS' CONTENTS:
  P1 - 0xFF
  P3 - 0xFF
  P4 - 0xBF
  P5 - 0x9F
  P6 - 0xFF
  P7 - 
  P8 - 
  P9 - 0xB3
*/
}

void init_HIP0045(void) {
  P6 &= 0xBF; // enable HIP0045 by setting P6_6 (!CE @HIP0045) low

  RAM[0x7E] |= 0x4;

  RAM[0x7F] = RAM[0x7E];

  send_by_spi(RAM[0x7E], P5_5, P5_7, P5_6);
/*
  HIP0045 configured with byte 0x44 sent in following order: 
  D7I..D1I = 0010 0010

  D7I: out1 = 0 - RTFM
  D6I: out3 = 0
  D5I: out5 = 1 - main relay switch on
  D4I: out7 = 0

  D3I: out0 = 0 & P5.4 = on - tachometer off (?)
  D2I: out2 = 0
  D1I: out4 = 1 - MAF burnout (off ?)
  D0I: out5 = 0
*/
}

void init_HIP9010(void) {
  ADCON0_6 = 1; // ADCON0.6 = ADCON0.CLK = 1 - clock output enable through P1.6 (CLKOUT = OSCIN @ HIP9010)
  SYSCON &= 0x7F; // clear CLKP bit - CLKOUT freq = f_osc/6
  
  WAIT_MACHINE_CYCLES_BY_2(0x33);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);

#define turn_on_hip9010 P9 &= 0x7F /* enable SPI @ HIP9010 by setting P9.7 low = !CS @ HIP9010 */
#define turn_off_hip9010 P9 |= 0x80 /* disable SPI @ HIP9010 by setting P9.7 high = !CS @ HIP9010 */
/*  
  send 0x2C over SPI to HIP9010/9011 in the following order:
  B7..B0 = 0010 1100

  address = 00 - knock filter frequency
  data = 101100 = 44 (dec) = 8.02 kHz
*/
  turn_on_hip9010; 
  send_by_spi(FLASH[0x87A7] & KNOCK_SENSOR_FILTER_FREQUENCY_CONFIG_WORD_MASK, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);
  
/*
  send 0x41 over SPI to HIP9010/9011 in the following order:
  0100 0001

  address = 01 - reference filter frequency
  data = 000001 = 1 = 1.26 kHz
*/
  turn_on_hip9010;
  send_by_spi(KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD | KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);

/*
  send 0x93 over SPI to HIP9010/9011 in the following order:
  1001 0011

  address = 10 - balance control (gain ratio)
  data = 010011 = 13(dec) = 0.649
*/
  turn_on_hip9010;
  send_by_spi(FLASH[0x24EF + (FLASH[0x87A9] & 0x3F)] | KNOCK_SENSOR_BALANCE_CONTROL_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;

  WAIT_MACHINE_CYCLES_BY_2(0x0E);

/*
  send 0xC0 over SPI to HIP9010/9011 in the following order:
  1100 0000

  address = 110 - integrator time constant
  data = 0 = 40 usec
*/
  turn_on_hip9010;
  send_by_spi(FLASH[0xAE01 & 0x1F] | KNOCK_SENSOR_INTEGRATOR_TIME_CONSTANT_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);

/*
  send 0xE0 over SPI to HIP9010/9011 in the following order:
  1110 0000

  address = 110 - test/channel select/channel attenuate control
  data = 0:
  ta, tb, tc = 0 - output knock rectifier,
  channel 0 selected
  attenuation applied to knock filter
*/
  turn_on_hip9010;
  send_by_spi(KNOCK_SENSOR_TEST_CONFIG_WORD | KNOCK_SENSOR_TEST_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);

#undef turn_off_hip9010
#undef turn_on_hip9010
}

void init_interrupt_priorities(void) {
/*
set interrupt priorities:

interrupt group 5 - 11(bin) - 3 (highest)
interrupt group 4 - 01      - 1
interrupt group 3 - 10      - 2
interrupt group 2 - 10
interrupt group 1 - 10
interrupt group 0 - 00      - 0 (lowest)

IP0.OWDS and IP0.WDTS are cleared.
*/
}

// output: R1:R0 (R0 - low, R1 - high)
word check_sum_xram_fx00_to_f657(void) {
  word Result = 0x0001;
  
  if (!CHECK_BIT_AT(FLASH[0x873F], 1))
    DPTR = 0xF600;
  else if (!CHECK_BIT_AT(FLASH[0x8743], 4))
    DPTR = 0xF500;
  else
    DPTR = 0xF400;  // current case

  do {
    Result += XRAM[DPTR];
    ++DPTR;
  } while (DPTR != 0xF658);
}

// INPUT - R1:R0
//         R3:R2
//
// OUTPUT - R1:R0 = R1:R0 - R3:R2
//
// R1 - high, R0 - low
// R3 - high, R2 - low
word subtract_word(word A, word B) {
  return A - B; // subtract with borrow, CY bit is set if borrow needed
}

void init_xram(void) {
  word FlashPtr = 0xABF1;
  word XramPtr = 0xF7D5;
  
  for (byte B = 0xF8; B != 0; --B)
    XRAM[XramPtr++] = FLASH[FlashPtr++];

  XramPtr = 0xF675;
  for (word Cnt = 0x160; Cnt != 0; --Cnt)
    XRAM[XramPtr] = 0x00;
  
  XRAM[0xF97E] = 0x00;
  XRAM[0xF972] = 0x00;
  XRAM[0xF973] = 0x00;
  XRAM[0xF974] = 0x00;
}


/*
INTERRUPTS:
 - reset
 */

void reset_interrupt() noreturn {
  reset_init();
  
  if (PSW.F0) {
    init_pins();
  } else {
    init_pins();
  }

  RAM[0x7E] = 0x40;
  RAM[0x7F] = 0x40;

  P6 &= 0xFE; // hold 5V drop regulator by setting P6_0 (HOLD @ TLE4267) low

  // is it for HIP0045?
  for (R0 = 0x7C; R0 != 0x7E; ++R0)
    RAM[R0] = 0;

  init_HIP0045();
  init_HIP9010();
  
  enable_access_to_xram(); // xram = 0xF400..0xFFFF
  set_negative_edge_trigger_ext_int(0); // P3_2
  set_negative_edge_trigger_ext_int(1); // P3.3
  
  set_watchdog_frequency_divider(12 or 192); // TODO see WPSEL
  enable_serial0_badu_rate_prescaler();
  
  set_timer2_input_clock_divider(192); // timer2 input clock freq = f_osc/192
  disable_timer2_reload();
  timer2_compare_mode(1);
  set_timer2_function_timer_with_selected_frequency();
  
  set_prescaler_divider_ratio(timer1, 1, 2); // ratio for timer1 = 1:2
  set_prescaler_divider_ratio(timer0, 1, 2); // ratio for timer0 = 1:2

  set_positive_edge_trigger_ext_int(3); // P1_0
  set_positive_edge_trigger_ext_int(2); // P1_4
  
  set_compare_timer_input_clock_divider(2); // compare timer input clock at f_osc/2
  
  CTRELL = CTRELH = 0x00; // compare timer reload register (low and high halves)
  TL2 = TH2 = 0x00; // timer2 register
  
  assign_registers_to_compare_timer_with_mode0(5); // CMH5/CML5 registers are assigned to compare timer and compare mode 0 selected
  assign_registers_to_compare_timer2_with_mode1(0, 1, 2, 3, 4, 6, 7); // CMHx/CMLx (x=0..4, 6, 7) registers are assigned to compare timer2 and compare mode 1 selected
  
  PSW.F1 = 0;
  if (IP0.OWDS | IP0.WDTS) {
    PSW.F1 = 1;
  }
  
  init_interrupt_priorities();
  
  // clear ram up to 0x7B (incl) to 0
  for (R0 = 0x01; R0 != 0x7C; ++R0)
    RAM[R0] = 0x00;
  
  RAM[0x27] |= BIT_AT(PSW.F0, 3);
  RAM[0x20] |= BIT_AT(PSW.F1, 6);
  
  word R1_R0 = check_sum_xram_fx00_to_f657(); // R0 - low, R1 - high
  word R3_R2 = *(word *)(&XRAM[0xF658]);        // R2 - low, R3 - high
  R1_R0 = subtract_word(R1_R0, R3_R2);
  
  RAM[0x20] |= BIT_AT(R0 || R1, 7);
  
  init_xram();
  
  RAM[0x2D] |= BIT_AT(CHECK_BIT_AT(FLASH[0x873F], 4), 7);
  RAM[0x2E] |= BIT_AT(CHECK_BIT_AT(FLASH[0x873F], 5), 0);
  RAM[0x2E] |= BIT_AT(CHECK_BIT_AT(FLASH[0x873F], 2), 1);
}


