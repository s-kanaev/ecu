/*
TYPES:
 - byte - a byte
 - pin - a pin
*/

typedef uint8_t byte;
typedef uint16_t word;
typedef int pin;

//////////////////////////////// FUNCTIONS:
/* Send DATA byte over SPI interface described by
   MOSI (output), MISO (input) and CLK pins.
   Sends data over MOSI pin.
   Returns byte fetched on MISO pin.
   0 for MISO - no input. */
byte send_by_spi(byte DATA, pin MOSI, pin MISO, pin CLK);

/* Send DATA byte over I2C bus described by
   SDA (I/O), SCL (output).
   Returns if byte was ACK'ed */
bool send_by_i2c(byte DATA, pin SDA, pin SCL);
/* Read single byte over I2C bus described by
   SDA (I/O), SCL (output).
   Returns byte read */
byte read_on_i2c(pin SDA, pin SCL);

void enable_access_to_xram();
void disable_access_to_xram();

#define WAIT_MACHINE_CYCLES_BY_2(x) /* waits for x*2 machine cycles, x = 0 is 0x100 */
/* SET_BIT(3) = 0x08*/
#define SET_BIT(bit) ((1) << (bit))

#define SET_BIT_IN(v, bit)  \
do {                        \
  v |= SET_BIT(bit);        \
} while (0)

#define CLEAR_BIT_IN(v, bit)  \
do {                          \
  v &= ~SET_BIT(bit);         \
} while (0)

/* CHECK_BIT_AT(0x10, 4) is true */
#define CHECK_BIT_AT(val, bit) ((val) & SET_BIT(bit))

#define SWAP_NIBBLES(b) (((((byte)((b))) & 0x0F) << 4) | ((((byte)((b))) & 0xF0) >> 4))

// get low byte
#define LOW(w) ((byte)((word)(w) & 0x00FF))
// get high byte
#define HIGH(w) ((byte)(((word)(w) & 0xFF00) >> 8))

#define SET_HIGH(b) (((word)((byte)(b))) << 8)
#define SET_LOW(b) ((byte)(b))
#define COMPOSE_WORD(h, l) (SET_HIGH((h)) | SET_LOW((l)))

#define IS_NEGATIVE(x) ((x) & (1 << (8 * sizeof(x) - 1))) /* x < 0 */

//////////////////////////////// CONSTANTS
#define KNOCK_SENSOR_TEST_CONFIG_WORD ((byte)(0x00))
#define KNOCK_SENSOR_TEST_CONFIG_WORD_PREFIX ((byte)0xE0)
#define KNOCK_SENSOR_INTEGRATOR_TIME_CONSTANT_CONFIG_WORD_PREFIX ((byte)0xC0)
#define KNOCK_SENSOR_BALANCE_CONTROL_CONFIG_WORD_PREFIX ((byte)0x80)
#define KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD_PREFIX ((byte)0x40)
#define KNOCK_SENSOR_FILTER_FREQUENCY_CONFIG_WORD_MASK ((byte)0x3F)

#define KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD ((byte)0x01)

#define EEPROM_ADDRESS ((byte)0xA0)
#define EEPROM_SELECT_PAGE_BLOCK(addr, block) (((addr) & 0xFD) | (((bl) & 0x01) << 1))
// r = 1 - read, r = 0 - write
#define I2C_READ_ADDRESS(addr, r) (((addr) & 0xFE) | ((r) & 0x01)) 

//////////////////////////////// General purpose flags:
/*
PSW.5 (F0) - was previously working?
  0 = ignition was turned on for the first time.
PSW.1 (F1) - general purpose flag, boolean parameter employed in trampoline functions
*/

//////////////////////////////// MEMORY SECTIONS

////////////// RAM MAP
byte RAM[0x100] = {
  [0x00..0x07] = 0, // R0..R7 @ register bank 0
  [0x08..0x0f] = 0, // R0..R7 @ register bank 1
  [0x10..0x17] = 0, // R0..R7 @ register bank 2
  [0x18..0x1f] = 0, // R0..R7 @ register bank 3

  // the rest (up to 0x7B, incl.) is initialized with nil
  [0x20] = 0x00, // bit 6 (bit address 0x06) = copy of PSW.F1 // watchdog triggered?
                 // bit 7 (bit address 0x07) = if xram check sum was not valid

  [0x21] = 0x00, // bit 0 (bit address 0x08) = 1 if failed to read first 0x42 bytes from eeprom
  [0x22..0x26] = 0x00,

  [0x27] = 0x00,  // ???
                  // bit 2 (bit address 0x3A)
                  // bit 3 (bit address 0x3B) = copy of PSW.F0

  [0x28..0x2C] = 0x00,
  [0x2D] = 0x00,  // bit 7 = FLASH[873F] bit 4
  [0x2E] = 0x00,  // bit 0 = FLASH[873F] bit 5
                  // bit 1 = FLASH[873F] bit 2
  [0x2F..0x3C] = 0,
  
  [0x3D] = 0,     // packed offset and factor for FLASH[0xA2FD]
                  // factor - least significant three bits, will be SHL 5 = xxx0 0000
                  // offset - most significant five bits, will be SHR 3, max value = 0x1F

  [0x3E..0x4B] = 0,
  [0x4C] = 0,     // offset div 0x11 for tabel at FLASH[0x8AFB]
  [0x4D..0x5C] = 0,
  [0x5D] = 0,     // ???
  [0x5E] = 0x00,

  [0x5F] = 0x20,  // ???
  [0x60] = 0x03,  // ???
  [0x61] = 0x21,  // ???
  [0x62] = 0x00,  // ???

  [0x63] = 0x00,  // ???
  [0x64..0x71] = 0,
  [0x72] = 0,     // some status word ?
                  // bit 7
                  // bit 6
                  // bit 5  - ???
                  // bit 4
                  // bit 3
                  // bit 2
                  // bit 1
                  // bit 0
  [0x73..0x7B] = 0x00,

  [0x7C..0x7D] = 0x00,

  [0x7E..0x7F] = 0x40, // HIP0045 configuration words
  
#define STACK = 0x00
  [0xB4..0xFF] = STACK
#undef STACK
};

////////////// FLASH MAP
byte FLASH[0x10000] = {
  /* knock_sensor_balance_control_gain_ratio_table configuration words (bytes), lengts = 0x40 bytes  */
  [0x24EF] = 0x3F,
  [0x24F0] = 0x3F, 0x3F, 0x3F, 0x39, 0x34, 0x31, 0x2F, 0x2D, 0x2A, 0x28, 0x27, 0x25, 0x24, 0x23, 0x22, 0x21,
  [0x2500] = 0x20, 0x1F, 0x1E, 0x1D, 0x1D, 0x1D, 0x1C, 0x1C, 0x1B, 0x1B, 0x1A, 0x19, 0x19, 0x18, 0x18, 0x18,
  [0x2510] = 0x17, 0x16, 0x16, 0x16, 0x15, 0x15, 0x15, 0x14, 0x14, 0x14, 0x14, 0x13, 0x13, 0x13, 0x13, 0x13,
  [0x2520] = 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,

  [0x8069] = 0x00, // fallback data for XRAM[0xFF74]
  [0x806A] = 0x00, // fallback data for XRAM[0xFF75]
  [0x8093] = 0x00, // fallback data for XRAM[0xF770]

  [0x873F] = 0x3F,  // kitting bits: 0011 1111
                    // bit 0 - is there constant power for ECU; default = 1; 0 => FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 1 - is there EGO (exhaust gas oxygen) sensor; default = 1; 0 => FLASH[0xFFFF] = 0x01, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 2 - is there knock sensor; default = 1; 0 => FLASH[0xFFFF] = 0x03, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 3 - is there air temperature sensor; default = 1; 0 => FLASH[0xFFFF] = 0x07, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 4 - is there camshaft position sensor; default = 1; 0 => FLASH[0xFFFF] = 0x0F, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 5 - camshaft position sensor cross-section is aligned with TDC; default = 1; 0 => FLASH[0xFFFF] = 0x1F, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 6 - is there speed sensor; default = 0; 1 => FLASH[0xFFFF] = 0xBF, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 7 - is there CO potentiometer; default = 0; 1 => FLASH[0xFFFF] = 0x7F, 0 => FLASH[0xFFFF] = 0xFF
  [0x8740] = 0xC0,  // kitting bits: 1100 0000
                    // bit 0 - is there ABS; default = 0; 1 => FLASH[0xFFFE] = 0xFE, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 1 - is there EGR valve position sensor; default = 0; 1 => FLASH[0xFFFE] = 0xFD, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 2 - is there adsorber valve position; default = 0; 1 => FLASH[0xFFFE] = 0xFB, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 3 - is there power steering pressure sensor; default = 0; 1 => FLASH[0xFFFE] = 0xF7, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 4 - is there additional oxygen sensor (at absorber?); default = 0; 1 => FLASH[0xFFFE] = 0xEF, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 5 - does MAF have burnout function; default = 0; 1 = FLASH[0xFFFE] = 0xDF, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 6 - is there throttle position sensor; default = 1; 0 => FLASH[0xFFFE] = 0x3F, FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFE] = 0xFF, FLASH[0xFFFF] = 0xFF
                    // bit 7 - is there coolant temperature sensor; default = 1; 0 => FLASH[0xFFFE] = 0x7F, FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFE] = 0xFF, FLASH[0xFFFF] = 0xFF
  [0x8741] = 0x23,  // kitting bits: 0010 0011
                    // bit 0 - is there IROM; default = 1; 0 => FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 1 - should DAC be corrected from IROM; default = 1; 0 => FLASH[0xFFFF] = 0x01, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 2 - is there immobilizer; default = 0; 1 => FLASH[0xFFFF] = 0xFB, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 3 - should RCO be corrected from IROM; default = 0; 1 => FLASH[0xFFFF] = 0xF7, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 4 - should fuel be blocked; default = 0; 1 => FLASH[0xFFFF] = 0xEF, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 5 - should fuel intake be asynchronous on second launch attempt; default = 1; 0 => FLASH[0xFFFF] = 0x1F, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 6 - should throttle position sensor adaptation be done; default = 0; 1 => FLASH[0xFFFF] = 0xBF, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 7 - should idle speed be adapted; default = 0; 1 => FLASH[0xFFFF] = 0x7F, 0 => FLASH[0xFFFF] = 0xFF
  [0x8742] = 0xC0,  // kitting bits: 1100 0000
                    // bit 0 - should bypass valve be adapted at idle; default = 0; 1 => FLASH[0xFFFE] = 0xFE, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 1 - is EGO with heating control; default = 0; 1 => FLASH[0xFFFE] = 0xFD, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 2 - reserved?
                    // bit 3 - reserved?
                    // bit 4 - reserved?
                    // bit 5 - reserved?
                    // bit 6 - are there injectors; default = 1; 0 => FLASH[0xFFFE] = 0x3F, FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFE] = 0xFF, FLASH[0xFFFF] = 0xFF
                    // bit 7 - are there ignition coils; default = 1; 0 => FLASH[0xFFFE] = 0x7F, FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFE] = 0xFF, FLASH[0xFFFF] = 0xFF

  [0x8743] = 0x13,  // kitting bits: 0001 0011
                    // bit 0 - is there check-engine lamp; default = 1; 0 => FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 1 - is there fuel pump; default = 1; 0 => FLASH[0xFFFF] = 0x01, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 2 - is there start injector; default = 0; 1 => FLASH[0xFFFF] = 0xFB, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 3 - is there EGR valve; default = 0; 1 => FLASH[0xFFFF] = 0xF7, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 4 - is there adsorber; default = 1; 0 => FLASH[0xFFFF] = 0x0F, 1 => FLASH[0xFFFF] = 0xFF
                    // bit 5 - is there tachometer; default = 0; 1 => FLASH[0xFFFF] = 0xDF, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 6 - is there fuel meter display; default = 0; 1 => FLASH[0xFFFF] = 0xBF, 0 => FLASH[0xFFFF] = 0xFF
                    // bit 7 - is there AirConditioner; default = 0; 1 => FLASH[0xFFFF] = 0x7F, 0 => FLASH[0xFFFF] = 0xFF

  [0x8744] = 0x05,  // kitting bits: 0000 0101
                    // bit 0 - is there fan; default = 1; 0 => FLASH[0xFFFE] = 0x00, FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFE] = 0xFF, FLASH[0xFFFF] = 0xFF
                    // bit 1 - reserved?
                    // bit 2 - is there bypass valve; default = 1; 0 => FLASH[0xFFFE] = 0x03, FLASH[0xFFFF] = 0x00, 1 => FLASH[0xFFFE] = 0xFF, FLASH[0xFFFF] = 0xFF
                    // bit 3 - is there idle economizer valve (carb); default = 0; 1 => FLASH[0xFFFE] = 0xF7, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 4 - is there secondary air compressor; default = 0; 1 => FLASH[0xFFFE] = 0xEF, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 5 - is intake controlled; default = 0; 1 => FLASH[0xFFFE] = 0xDF, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 6 - is there VVT; default = 0; 1 => FLASH[0xFFFE] = 0xBF, 0 => FLASH[0xFFFE] = 0xFF
                    // bit 7 - reserved?

  [0x8761] = 0x00,  // ???

  /* knock sensor knock filter frequency configuration word */
  [0x87A7] = 0x2C,

  /* offset for knock sensor balance control gain ratio table @ 0x24EF */
  [0x87A9] = 0x30,
  
  /* ?????????????????????? */
  //                  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f     10
  [0x8AFB..0x8C0A] = 0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBD,
  //                  11    12    13    14    15    16    17    18    19    1a    1b    1c    1d    1e    1f    20    21
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBD,
  //                  22    23    24    25    26    27    28    29    2a    2b    2c    2d    2e    2f    30    31    32
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBD,
  //                  33    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     43
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9D, 0xBB,
  //                  44    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     54
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  55    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     65
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  66    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     76
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  77    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     87
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  88    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     98
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  99    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     a9
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  aa    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     ba
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  bb    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     cb
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  cc    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     dc
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  dd    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     ed
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  ee    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     fe
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,
  //                  ff    .     .     .     .     .     .     .     .     .     .     .     .     .     .     .     10f
                     0x05, 0x17, 0x26, 0x31, 0x3B, 0x43, 0x4A, 0x4F, 0x54, 0x5B, 0x64, 0x69, 0x72, 0x7B, 0x8A, 0x9C, 0xBB,

  /* EGO sensor calibration */
  [0x991C..0x99AB] = 0x59, 0x59, 0x5A, 0x5A, 0x5B, 0x5C, 0x5E, 0x5F,
                     0x60, 0x60, 0x5F, 0x5E, 0x5E, 0x5F, 0x60, 0x61,
                     0x5B, 0x5B, 0x5B, 0x5B, 0x5C, 0x5D, 0x5D, 0x5E,
                     0x5F, 0x5E, 0x5F, 0x5F, 0x5F, 0x60, 0x61, 0x62,
                     0x5C, 0x5C, 0x5C, 0x5C, 0x5D, 0x5E, 0x61, 0x61,
                     0x60, 0x60, 0x61, 0x60, 0x60, 0x61, 0x62, 0x63,
                     0x65, 0x64, 0x63, 0x63, 0x65, 0x66, 0x66, 0x66,
                     0x66, 0x64, 0x65, 0x64, 0x65, 0x66, 0x67, 0x68,
                     0x6B, 0x6B, 0x6B, 0x6A, 0x69, 0x69, 0x68, 0x67,
                     0x68, 0x67, 0x69, 0x69, 0x69, 0x68, 0x68, 0x69,
                     0x70, 0x6E, 0x6C, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B,
                     0x69, 0x6A, 0x6A, 0x6B, 0x6A, 0x69, 0x69, 0x69,
                     0x73, 0x72, 0x71, 0x6F, 0x6D, 0x6C, 0x6B, 0x6B,
                     0x6B, 0x6B, 0x6C, 0x6B, 0x6A, 0x6A, 0x6A, 0x69,
                     0x78, 0x76, 0x74, 0x70, 0x6E, 0x6D, 0x6C, 0x6C,
                     0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6A,
                     0x77, 0x77, 0x77, 0x75, 0x73, 0x6F, 0x6E, 0x6E,
                     0x6C, 0x6C, 0x6D, 0x6C, 0x6C, 0x6C, 0x6C, 0x6B,
                     0x77, 0x76, 0x75, 0x74, 0x72, 0x70, 0x6F, 0x6E,
                     0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6C, 0x6C, 0x6B,
                     0x7A, 0x79, 0x77, 0x76, 0x74, 0x72, 0x71, 0x6F,
                     0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6D,
                     0x7C, 0x7B, 0x7A, 0x78, 0x76, 0x74, 0x73, 0x72,
                     0x71, 0x70, 0x6F, 0x6F, 0x6F, 0x6E, 0x6F, 0x6E,
                     0x79, 0x78, 0x77, 0x76, 0x75, 0x73, 0x72, 0x70,
                     0x70, 0x70, 0x6F, 0x70, 0x6F, 0x6E, 0x71, 0x70,
                     0x7B, 0x7A, 0x77, 0x74, 0x74, 0x74, 0x75, 0x72,
                     0x71, 0x73, 0x70, 0x71, 0x6F, 0x71, 0x73, 0x72,
                     0x7C, 0x7B, 0x78, 0x76, 0x77, 0x75, 0x75, 0x71,
                     0x71, 0x73, 0x71, 0x73, 0x74, 0x76, 0x73, 0x72,
                     0x7A, 0x79, 0x78, 0x77, 0x78, 0x75, 0x75, 0x72,
                     0x71, 0x72, 0x72, 0x74, 0x74, 0x74, 0x73, 0x72,

  // ????????????????
  [0xA2FD..0xA31D] = 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
                     0xFB, 0xFB, 0xF9, 0xF7, 0xF5, 0xF0, 0xE6, 0xD7,
                     0xC8, 0xB9, 0xAD, 0xA6, 0xA0, 0x9D, 0x9A, 0x9A,
                     0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A,
                     0x9A,

  // ????????????????
  [0xABF1..0xACE8] = 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
                     0x02, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06,
                     0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
                     0x0F, 0x10, 0x12, 0x15, 0x18, 0x1B, 0x1E, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02,
                     0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
                     0x0B, 0x0C, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
                     0x12, 0x14, 0x17, 0x1B, 0x1E, 0x22, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x02, 0x03, 0x04, 0x05, 0x06,
                     0x07, 0x09, 0x0B, 0x0C, 0x0E, 0x0F, 0x10, 0x11,
                     0x12, 0x13, 0x14, 0x14, 0x14, 0x14, 0x15, 0x16,
                     0x17, 0x18, 0x1A, 0x1F, 0x26, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                     0x0B, 0x0E, 0x11, 0x14, 0x17, 0x1B, 0x1F, 0x22,
                     0x24, 0x25, 0x26, 0x26, 0x26, 0x26, 0x25, 0x24,
                     0x23, 0x23, 0x23, 0x23, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
                     0x03, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                     0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x11, 0x13,
                     0x15, 0x17, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03,
                     0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
                     0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x11, 0x13, 0x15,
                     0x17, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03,
                     0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
                     0x0C, 0x0D, 0x0E, 0x0F, 0x11, 0x13, 0x15, 0x17,
                     0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                     0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04,
                     0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                     0x0D, 0x0E, 0x0F, 0x11, 0x13, 0x15, 0x17, 0x19,

  /* knock sensor integration time constant configuration word */
  [0xAE01] = 0x00,

  [0xFFFE] = 0xFF,
  [0xFFFF] = 0xFF
};

////////////// XRAM MAP
byte XRAM[0xC00] = /* [0xF400..0x10000] address space */ {
  [0xF400..0xF4FF] = 0,
  [0xF500..0xF5FF] = 0,                       // EGO calibration
  [0xF600] = 0,
  [0xF602] = FLASH[0x8761],                   // Set to FLASH[0x8761] if and only if watchdog triggered or xram checksum failed (power-on?)
                                              // Signed byte value.
                                              // Differentiated versus RAM[0x63].
  [0xF603] = 0x01,                            // Set to 0x01 if and only if watchdog triggered or xram checksum failed (power-on?)
  [0xF605..0xF657] = 0,

  [0xF658] = 0,                               // checksum low byte (for 0xFx00..0xF657)
  [0xF659] = 0                                // checksum high byte (for 0xFx00..0xF657)
  [0xF675..0xF7D4] = 0x00,                    // 0x160 bytes
  [0xF7D5..0xF8CC] = FLASH[0xABF1..0xACE8]    // 0xF8 bytes

  [0xF97E] = 0x00,
  [0xF972] = 0x00,
  [0xF973] = 0x00,
  [0xF974] = 0x00,
  
  [0xFF00..0xFF41] = EEPROM[0x00..0x41],
  [0xFF42..0xFF73] = EEPROM[0x41..0x73],
  [0xFF74..0xFF7F] = EEPROM[0x74..0x7F]
};

////////////// EEPROM MAP
byte EEPROM[0x200] = {
  [0x00..0x41] = 0x00, // oh, rly?
  [0x41..0x73] = 0x00, // oh, rly?
  [0x74..0x7F] = 0x00, // oh, rly?
};

//////////////////////////////// Pins

enum Pins {
  P0_0 = 1,
  P0_1,
  // and so on and on and on ...
  P9_7
};


//////////////////////////////// Auxiliary functions

inline bool status_watchdog_triggerred() {
  return CHECK_BIT_AT(RAM[0x20], 6);
}

inline bool status_xram_checksum_invalid() {
  return CHECK_BIT_AT(RAM[0x20], 7);
}


inline bool kitting_has_ego() {
  return CHECK_BIT_AT(FLASH[0x873F], 1);
}

inline bool kitting_has_absorber() {
  return CHECK_BIT_AT(FLASH[0x8743], 4);
}


void reset_init(void) {
  disable_interrupts();
  clear_stack();
  reset_interrupt_requests();
  disable_access_to_xram();
  set_clk_out_prescaler(12); // clkout freq = f_osc/12
  select_dptr(0);
}

void init_pins(void) {
/*
  *** SUMMARY ***
  Bidirectional port structure employed.

  PORTS' DIRECTIONS:
  P0 - all in
  P1 - 2, 3 - in; other - out
  P2 - all in
  P3 - 0, 3, 5 - in; other - out
  P4 - 7 - in; others - out
  P5 - 7 - in; others - out
  P6 - all out
  P7 - 
  P8 - 
  P9 - 0, 4, 5 - in; other - out

  PORTS' CONTENTS:
  P1 - 0xFF
  P3 - 0xFF
  P4 - 0xBF
  P5 - 0x9F
  P6 - 0xFF
  P7 - 
  P8 - 
  P9 - 0xB3
*/
}

void init_HIP0045(void) {
  P6 &= 0xBF; // enable HIP0045 by setting P6_6 (!CE @HIP0045) low

  RAM[0x7E] |= 0x4;

  RAM[0x7F] = RAM[0x7E];

  send_by_spi(RAM[0x7E], P5_5, P5_7, P5_6);
/*
  HIP0045 configured with byte 0x44 sent in following order: 
  D7I..D1I = 0010 0010

  D7I: out1 = 0 - RTFM
  D6I: out3 = 0
  D5I: out5 = 1 - main relay switch on
  D4I: out7 = 0

  D3I: out0 = 0 & P5.4 = on - tachometer off (?)
  D2I: out2 = 0
  D1I: out4 = 1 - MAF burnout (off ?)
  D0I: out5 = 0
*/
}

void init_HIP9010(void) {
  ADCON0_6 = 1; // ADCON0.6 = ADCON0.CLK = 1 - clock output enable through P1.6 (CLKOUT = OSCIN @ HIP9010)
  SYSCON &= 0x7F; // clear CLKP bit - CLKOUT freq = f_osc/6
  
  WAIT_MACHINE_CYCLES_BY_2(0x33);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);
  WAIT_MACHINE_CYCLES_BY_2(0);

#define turn_on_hip9010 P9 &= 0x7F /* enable SPI @ HIP9010 by setting P9.7 low = !CS @ HIP9010 */
#define turn_off_hip9010 P9 |= 0x80 /* disable SPI @ HIP9010 by setting P9.7 high = !CS @ HIP9010 */
/*  
  send 0x2C over SPI to HIP9010/9011 in the following order:
  B7..B0 = 0010 1100

  address = 00 - knock filter frequency
  data = 101100 = 44 (dec) = 8.02 kHz
*/
  turn_on_hip9010; 
  send_by_spi(FLASH[0x87A7] & KNOCK_SENSOR_FILTER_FREQUENCY_CONFIG_WORD_MASK, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);
  
/*
  send 0x41 over SPI to HIP9010/9011 in the following order:
  0100 0001

  address = 01 - reference filter frequency
  data = 000001 = 1 = 1.26 kHz
*/
  turn_on_hip9010;
  send_by_spi(KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD | KNOCK_SENSOR_REFERENCE_FILTER_FREQUENCY_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);

/*
  send 0x93 over SPI to HIP9010/9011 in the following order:
  1001 0011

  address = 10 - balance control (gain ratio)
  data = 010011 = 13(dec) = 0.649
*/
  turn_on_hip9010;
  send_by_spi(FLASH[0x24EF + (FLASH[0x87A9] & 0x3F)] | KNOCK_SENSOR_BALANCE_CONTROL_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;

  WAIT_MACHINE_CYCLES_BY_2(0x0E);

/*
  send 0xC0 over SPI to HIP9010/9011 in the following order:
  1100 0000

  address = 110 - integrator time constant
  data = 0 = 40 usec
*/
  turn_on_hip9010;
  send_by_spi(FLASH[0xAE01 & 0x1F] | KNOCK_SENSOR_INTEGRATOR_TIME_CONSTANT_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);

/*
  send 0xE0 over SPI to HIP9010/9011 in the following order:
  1110 0000

  address = 110 - test/channel select/channel attenuate control
  data = 0:
  ta, tb, tc = 0 - output knock rectifier,
  channel 0 selected
  attenuation applied to knock filter
*/
  turn_on_hip9010;
  send_by_spi(KNOCK_SENSOR_TEST_CONFIG_WORD | KNOCK_SENSOR_TEST_CONFIG_WORD_PREFIX, P1_5, NULL, P9_6);
  turn_off_hip9010;
  
  WAIT_MACHINE_CYCLES_BY_2(0x0E);

#undef turn_off_hip9010
#undef turn_on_hip9010
}

void init_interrupt_priorities(void) {
/*
set interrupt priorities:

interrupt group 5 - 11(bin) - 3 (highest)
interrupt group 4 - 01      - 1
interrupt group 3 - 10      - 2
interrupt group 2 - 10
interrupt group 1 - 10
interrupt group 0 - 00      - 0 (lowest)

IP0.OWDS and IP0.WDTS are cleared.
*/
}

// output: R1:R0 (R0 - low, R1 - high)
word check_sum_xram_fx00_to_f657(void) {
  word Result = 0x0001;
  word Ptr = 0xF400; // current case: both EGO and absorber are present
  
  if (!kitting_has_ego()) // There is no EGO
    Ptr = 0xF600;
  else if (!kitting_has_absorber()) // There is no absorber
    Ptr = 0xF500;

  do {
    Result += XRAM[Ptr++];
  } while (Ptr != 0xF658);
}

// INPUT - R1:R0
//         R3:R2
//
// OUTPUT - R1:R0 = R1:R0 - R3:R2
//
// R1 - high, R0 - low
// R3 - high, R2 - low
word subtract_word(word A, word B) {
  return A - B; // subtract with borrow, CY bit is set if borrow needed
}

void init_xram(void) {
  word FlashPtr = 0xABF1;
  word XramPtr = 0xF7D5;
  
  for (byte Cnt = 0xF8; Cnt != 0; --Cnt)
    XRAM[XramPtr++] = FLASH[FlashPtr++];

  XramPtr = 0xF675;
  for (word Cnt = 0x160; Cnt != 0; --Cnt)
    XRAM[XramPtr] = 0x00;
  
  XRAM[0xF97E] = 0x00;
  XRAM[0xF972] = 0x00;
  XRAM[0xF973] = 0x00;
  XRAM[0xF974] = 0x00;
}

void nullify_xram(word XramPtr, byte Bytes) {
  do {
    XRAM[XramPtr++] = 0x00;
  } while (Bytes != 0);
}

word sum_xram(word XramPtr, byte WordCount) {
  word Sum = 0x0001;

  do {
    Sum += *(word *)(&XRAM[XramPtr++]);
    --WordCount;
  } (WordCount != 0);
  
  return Sum;
}

void mark_eeprom_failure(void) {
  RAM[0x21] |= BIT_AT(1, 0);
}

void read_eeprom_to_xram(void) {
  word XramPtr = 0xFF00;
  byte Offset = 0;
  
  // send slave address + page block selector (0)
  if (!send_by_i2c(0, P3_3, P1_7)) {
    mark_eeprom_failure();
    nullify_xram(0xFF30, 0x10);
  }
  
  // send word address (byte offset in page block)
  if (!send_by_i2c(Offset, P3_3, P1_7)) {
    mark_eeprom_failure();
    nullify_xram(0xFF30, 0x10);
  }
  
  byte Size = 0x42;
  for (int Idx = 0; Idx < Size; ++Idx)
    XRAM[XramPtr++] = read_on_i2c(P3_3, P1_7);
  
  if (sum_xram(XramPtr - Size, Size >> 1)) {
    mark_eeprom_failure();
  }
  
  Offset += Size;

  //////////////////////////////////////////////////////

  // send slave address + page block selector (0)
  if (!send_by_i2c(0, P3_3, P1_7)) {
    mark_eeprom_failure();
    nullify_xram(0xFF30, 0x10);
  }

  // send word address (byte offset in page block)
  if (!send_by_i2c(Offset, P3_3, P1_7)) {
    mark_eeprom_failure();
  }

  Size = 0x32;
  for (int Idx = 0; Idx < Size; ++Idx)
    XRAM[XramPtr++] = read_on_i2c(P3_3, P1_7);

  if (sum_xram(XramPtr - Size, Size >> 1)) {
    mark_eeprom_failure();
  }
  
  Offset += Size;
  
  //////////////////////////////////////////////////////

  // send slave address + page block selector (0)
  if (!send_by_i2c(0, P3_3, P1_7)) {
    mark_eeprom_failure();
    nullify_xram(0xFF30, 0x10);
  }

  // send word address (byte offset in page block)
  if (!send_by_i2c(Offset, P3_3, P1_7)) {
    mark_eeprom_failure();
  }

  Size = 0x0C;
  for (int Idx = 0; Idx < Size; ++Idx)
    XRAM[XramPtr++] = read_on_i2c(P3_3, P1_7);

  if (sum_xram(XramPtr - Size, Size >> 1)) {
    mark_eeprom_failure();
  }
}

void no_eeprom(void) {
  XRAM[0xFF74] = FLASH[0x8069];
  XRAM[0xFF75] = FLASH[0x806A];
  XRAM[0xF770] = FLASH[0x8093];
}

// close idle air intake valve
void close_bypass_air_valve(void) {
  CLEAR_BIT_IN(P1, 0);
  SET_BIT_IN(P1, 1);
}

// open idle air intake valve
void open_bypass_air_valve(void) {
  CLEAR_BIT_IN(P1, 1);
  SET_BIT_IN(P1, 0);
}

// FlashPtr - location of table in FLASH
// Input - packed offset and factor
//         factor - least significant three bits, will be SHL 5, max value = 0x1F
//         offset - most significant five bits, will be SHR 3, eq xxx0 0000)
// Negate - should table data be XOR'ed with 0x80 (negated?)
// Returns - result:
//           T[N] in high byte and zero in low byte if factor eq nil,
//           factor*(T[N+1] - T[N])
//  6352:
word TableLookup(word FlashPtr, byte Input, bool Negate) {
  byte Offset = (Input & 0xF8) >> 3; //R3 = tripple_rotate_right(R2, 0x1F); // maximum value = 1F
  byte Factor = (Input & 0x07) << 5; // A = tripple_rotate_right(R2, 0xE0); // Factor: xxx0 0000
// 635D:
  Input = Factor; // R2 = A

  if (!Factor)
    return COMPOSE_WORD(FLASH[FlashPtr + Offset], 0);

  byte TableData = FLASH[FlashPtr + Offset + 1];

  if (Negate)
    TableData ^= 0x80;

  word Prod1 = TableData * Factor; // A - low byte of result, B - high byte of result
  R0 = LOW(Prod);     // (byte)(Prod & 0xFF);
  R1 = HIGH(Prod);    //(byte)((Prod & 0xFF00) >> 8);

  B = -Factor; // negate and increment

  TableData = FLASH[FlashPtr + Offset];

  if (Negate)
    TableData ^= 0x80;
  
  word Prod2 = TableData * (-Factor);
  
  word Result = Prod1 + Prod2;
  
  if (Negate) {
    Result ^= 0x8000;
    CY = CHECK_BIT_AT(Result, 0x0F);
  }

  return Result;
}

void init_ram_63(byte TableDataHigh) {
  RAM[0x63] = TableDataHigh;
  byte XramData = XRAM[0xF602];

  if (IS_NEGATIVE(TableDataHigh)) {  // TableDataHigh & 0x80
    if (TableDataHigh >= XramData)
      RAM[0x63] = XramData - 1;

    return;
  }

  if (TableDataHigh < XramData)
    RAM[0x63] = XramData;
}


/*
INTERRUPTS:
 - reset
 */

void reset_interrupt() noreturn {
  reset_init();
  
  if (PSW.F0) {
    init_pins();
  } else {
    init_pins();
  }

/********************************
  CMEN = 0
  CCEN = 0
  CC4EN = 0
  TCON = 0
  TMOD = 0
  T2CON = 0
  CTCON = 0x40, compare timer freq = f_osc/2
  CT1CON = 0x40, freq = f_osc / 2
  IEN0 = 0 - disable interrupts: all, timer2, serial channel 0, timer1 overflow, external 1, timer0 overflow, external 0
  IEN1 = 0 - disable interrupts: timer2 external reload, external interrupts 2-6, adc
  IEN2 = 0 - disable interrupts: register compare match interrupt, compare timer interrupt, CM0-7 compare match interrupt, serial iface1
  IEN3 = 0 - disable interrupts: compare timer1 overflow, compare timer1 - general capture/compare interrupt.
  PRSC = 0xD5 - T2P1 = 0; T2P0 = 1 - set timer2 freq = f_osc/12 or f_osc/24
                T1P1 = 0; T1P0 = 1 - divider ration = 1:2
                T0P1 = 0; T0P0 = 1 - divider ration = 1:2


  CMSEL
  CAFR
  CRCH CRCL
  COMSETL COMSETL
  SETMSK CLRMSK
  CTRELH CTRELL
  CT1RELH CT1RELL
  TH2 TL2
********************************/

  RAM[0x7E] = 0x40;
  RAM[0x7F] = 0x40;

  P6 &= 0xFE; // hold 5V drop regulator by setting P6_0 (HOLD @ TLE4267) low

  // is it for HIP0045?
  for (R0 = 0x7C; R0 != 0x7E; ++R0)
    RAM[R0] = 0;

  init_HIP0045();
  init_HIP9010();
  
  enable_access_to_xram(); // xram = 0xF400..0xFFFF
  // TCON.IT0 = 1, negative edge triggered external interrupt 0 (external interrupt 0 is at P3.2, which isn't connected to anywhere)
  // TCON.IT1 = 1, negative edge triggered external interrupt 1 (external interrupt 1 is at P3.3 - SDA @ NM24C04 / AT24C04 (EEPROM, I2C))
  TCON |= SET_BIT(0) | SET_BIT(2);
  //set_negative_edge_trigger_ext_int(0); // P3_2
  //set_negative_edge_trigger_ext_int(1); // P3.3
  
  PRSC = 0xE5;  // PRSC = 0xE5 = 1110 0101
                // WDTP = 1 - watchdog freq f_osc/12 or f_osc/192
                // S0P = 1 - serial interface0 baud rate prescaler by 2 is active
                // T2P1 = 1; T2P0 = 0 - timer2 input clock = f_osc/192 (see T2PS and T2PS1)
                // T1P1 = 0; T1P0 = 1 - prescaler divider ratio for timer1 = 1:2
                // T0P1 = 0; T0P0 = 1 - prescaler divider ratio for timer0 = 1:2

  T2CON = 0xE5; // T2CON = 0xE5 = 1110 0101
                // T2PS = 1 - select timer2 frequency
                // I3FR = 1 - external interrupt 3 on positive edge on INT3 (P1.0)
                // I2FR = 1 - external interrupt 2 on positive edge on INT2 (P1.4)
                // T2R1 = 0; T2R0 = 0 - timer2 reload disabled
                // T2CM = 1 - timer2 compare mode 1 selected
                // T2I1 = 0; T2I0 = 1 - timer2 function - timer with selected frequency

  CTCON = 0xC0; // CTCON = 0xC0 = 1100 0000
                // T2PS1 = 1 - select timer2 freq
                // ICR = 0; ICS = 0; CTF = 0 - these bits are set by hw on interrupt
                // CTP = 1; CLK2 = 0; CLK1 = 0; CLK0 = 0 - compare timer input clock at f_osc/2

  //set_watchdog_frequency_divider(12 or 192); // TODO see WPSEL
  //enable_serial0_baud_rate_prescaler();
  
  //set_timer2_input_clock_divider(192); // timer2 input clock freq = f_osc/192
  //disable_timer2_reload();
  //timer2_compare_mode(1);
  //set_timer2_function_timer_with_selected_frequency();

  //set_prescaler_divider_ratio(timer1, 1, 2); // ratio for timer1 = 1:2
  //set_prescaler_divider_ratio(timer0, 1, 2); // ratio for timer0 = 1:2

  //set_positive_edge_trigger_ext_int(3); // P1_0
  //set_positive_edge_trigger_ext_int(2); // P1_4
  
  //set_compare_timer_input_clock_divider(2); // compare timer input clock at f_osc/2
  
  CTRELL = CTRELH = 0x00; // launch compare timer ; compare timer reload register (low and high halves)
  TL2 = TH2 = 0x00; // launch timer2? ; timer2 register
  
  CMSEL = 0x20; // CMSEL = 0x20 = 0010 0000
                // Assign CML5/CMH5 registers to the compare timer and compare mode 0 selected.
                // Other CMLx/CMHx (x = 0..4, 6, 7) registers are assigned to compare timer 2 and compare mode 1 selected.
                // CMEN = 0 for the time being
  //assign_registers_to_compare_timer_with_mode0(5); // CMH5/CML5 registers are assigned to compare timer and compare mode 0 selected
  //assign_registers_to_compare_timer2_with_mode1(0, 1, 2, 3, 4, 6, 7); // CMHx/CMLx (x=0..4, 6, 7) registers are assigned to compare timer2 and compare mode 1 selected
  
  PSW.F1 = 0;
  if (IP0.OWDS | IP0.WDTS) {
    PSW.F1 = 1;
  }
  
  init_interrupt_priorities();
  
  // clear ram up to 0x7B (incl) to 0
  for (R0 = 0x01; R0 != 0x7C; ++R0)
    RAM[R0] = 0x00;
  
  RAM[0x27] |= SET_BIT(PSW.F0, 3);
  RAM[0x20] |= SET_BIT(PSW.F1, 6);

  word R1_R0 = check_sum_xram_fx00_to_f657(); // R0 - low, R1 - high
  word R3_R2 = *(word *)(&XRAM[0xF658]);      // R2 - low, R3 - high
  R1_R0 = subtract_word(R1_R0, R3_R2);
  
  RAM[0x20] |= SET_BIT(R0 || R1, 7);
  
  init_xram();
  
  RAM[0x2D] |= SET_BIT(CHECK_BIT_AT(FLASH[0x873F], 4), 7); // Has camshaft position sensor
  RAM[0x2E] |= SET_BIT(CHECK_BIT_AT(FLASH[0x873F], 5), 0); // Camshaft position sensor cross-section is aligned with TDC
  RAM[0x2E] |= SET_BIT(CHECK_BIT_AT(FLASH[0x873F], 2), 1); // Is there knock sensor
  
  if (CHECK_BIT_AT(FLASH[0x8741], 0)) // Is there IROM?
    read_eeprom_to_xram();
  else
    no_eeprom();
  
  SET_BIT_IN(PCON, 7); // PCON.SMOD = 1, When set, the baud rate of serial interface 0 in modes 1, 2, 3 is doubled
  SET_BIT_IN(ADCON0, 7); // ADCON0.BD = 1, When set, the baud rate of serial interface 0 is derived from a dedicated baud rate generator.
  
  RAM[0x5F] = 0x20;
  RAM[0x60] = 0x03;
  RAM[0x61] = 0x21;
  RAM[0x62] = 0x00;
  
  open_bypass_air_valve();
  
  CCL1 = RAM[0x5F]; CCH1 = RAM[0x60];
  CRCL = CCL1 + 0x28; CRCH = CCH1 + 0x00;
  
  CCEN |= SET_BIT(1) | SET_BIT(3); // Timer2: Compare enabled for CC register 0 (CRC = CRCH:CRCL) and CC register 1 (CC1 = CCH1:CCL1)
                                               // FYI:
                                               //  - Timer2 is in compare mode 1;
                                               //  - freq = f_osc/192;
                                               //  - reload disabled;
                                               //  - input - timer with selected frequency; 
                                               //  - external interrupt 3 on positive edge on INT3 (P1.0);
                                               //  - external interrupt 2 on positive edge on INT2 (P1.4);
  close_bypass_air_valve();
  
  SET_BIT_IN(IEN1, 2);     // External interrupt 3 / capture/compare interrupt 0 enable
  CLEAR_BIT_IN(IEN1, 3);    // External interrupt 4 / capture/compare interrupt 0 enable
  
  // Closing of bypass intake air valve is scheduled at TH2:TL2 = CRC (mode 1 of timer2 operation)
  
  if (status_watchdog_triggerred() || status_xram_checksum_invalid()) {
    XRAM[0xF602] = FLASH[0x8761]; // 0
    XRAM[0xF603] = 0x01;
    
    if (kitting_has_ego()) {
      word XramPtr = 0xF500;
      word FlashPtr = 0x991C;
      
      for (int Cnt = 0; Cnt < 0x100; ++Cnt)
        XRAM[XramPtr++] = FLASH[FlashPtr++];
    }
    
    XRAM[0xF600] = 0x80;
    
    {
      word XramPtr = 0xF605;
      
      for (byte Cnt = 0; Cnt < 0x53; ++Cnt)
        XRAM[XramPtr++] = 0;
    }
  }

  word TableData = TableLookup(0xA2FD, 0, false);
  init_ram_63(HIGH(TableData));
}

///////////////////////////////////////////////////////////////////////
// TEMPORARY
///////////////////////////////////////////////////////////////////////

inline byte tripple_rotate_right(byte Data, byte Mask) {
  Data = ((Data & 0x0F) << 4) | ((Data & 0xF0) >> 4); // swap nibbles
  Data = (Data << 1) | (Data >> 7);          // rotate left
  return Data & Mask;
}

/*
  Lookup value in the table in FLASH.
  Input:
   - Input - value to look up.
   - FlashPtr - pointer to the first table value.

  Table size = 0x11 bytes.

  Output byte is packed:
   - high nibble = Idx of last value less or equal than Input
   - low nibble = offset of Input in interval Table[Idx]..Table[Idx + 1]
  That is: MSB..LSB: xxxx yyyy,
           xxxx = Idx of last value less or equal than Input;
           yyyy = offset of Input in interval FLASH[FlashPtr + Idx]..FLASH[FlashPtr + Idx + 1]

  Saturation is performed if Input is out of bounds of the Table.
*/
byte _6280(byte Input, word FlashPtr) {
  R0 = Input;
  byte Idx = 0; // max valid value = 0x0f

  for (Idx = 0; (Idx <= 0x10) && (Input >= CurrentFlashVal); ++Idx)
    ;

  if (Idx == 0x10)
    return 0xFF;  // saturate to the last value in the table

  byte CurrentFlashVal = FLASH[FlashPtr + Idx];

  // CurrentFlashVal is the first value larger than Input.
  // Input is expected to be between previous value and current value.

  if (!Idx)
    return 0x00; // saturate to the first value in the table

  --Idx;
  // Max Idx value at the time = 0x0e.

  byte LesserVal = FLASH[FlashPtr + Idx];
  byte LargerVal = CurrentFlashVal;
  // Input is between LesserVal and LargerVal.

  if (LesserVal == LargerVal)
    return SWAP_NIBBLES(Idx); // high nibble is the index itself

  byte IntervalWidth = LargerVal - LesserVal;

  byte Quot;

  CLEAR_BIT_IN(RAM[0x27], 2); // we don't need to divide twice
_62AF: // looks like point of changes for modification FW setup
  do {
    Quot = LOW((0x10 * InputOffset) / IntervalWidth);

    if (CHECK_BIT_AT(RAM[0x27], 2))
      CLEAR_BIT_IN(RAM[0x27], 2);
    else
      break;
  } while (1);
  
  SET_BIT_IN(RAM[0x27], 2);

  return SWAP_NIBBLES(Idx) + Quot;
}






